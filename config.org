#+TITLE: Doom Emacs Konfiguration
#+AUTHOR: Stefan Schuh
#+STARTUP: content

* Allgemein
** Header :noexport:
#+begin_src emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
#+end_src
** Fonts
Um den richtigen Namen einer Schriftart zu finden, verwende =M-x discribe-font=.

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Triplicate A Code" :size 20))
#+end_src
*** Symbolschriftarten
Wenn die Fonts in der Modeline nicht funktionieren, müssen vielleicht noch Schriften nachinstalliert werden:

#+begin_src elisp :tangle no
(nerd-icons-install-fonts)
#+end_src

** Funktionen
*** =async-shell-command-no-window=
Ich möchte manchmal asynchrone Shell-Kommandos ausführen, aber u. U. den Puffer "Asynchronous Shell Command" nicht sehen. Anwendungsbeispiel: Wenn ich den HTML-Report von XSPEC bereits offen habe, interessiert mich der Shell output nicht. Nachdem =async-shell-command= keine einfache Option hat, den Puffer zu unterdrücken, habe ich das hier gefunden:

#+begin_src elisp
(defun async-shell-command-no-window
    (command)
  (interactive)
  (let
      ((display-buffer-alist
        (list
         (cons
          "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+end_src
** Userinfo
#+begin_src elisp
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "Stefan Schuh"
      user-mail-address "stefan.schuh@obvsg.at")
#+end_src

** UI
*** Theme
#+begin_src elisp
(setq doom-theme 'doom-solarized-dark)
#+end_src
*** Window selection
In =init.el= habe ich =(window-select +numbers)= aktiviert. Window selection geht nun über =SPC w {n}=, wobei =n= die Nummer des Fensters ist.

**** Ace Window
Als erstes brauchen wir =other-window= auf einer gut erreichbaren Stelle. =SPC w p= ist derzeit mit =evil-window-mru= belegt, einer Funktion, die ich noch nie verwendet habe. Weg damit, sie hat eh noch ein zweites Binding (=SPC w C-p=).

#+begin_src elisp
(map! :leader
      :desc "window switcher" "w p" #'other-window)
#+end_src

Macht die Hints von =ace-window= größer und bunter. Viel besser zu sehen. Das Snippet ist direkt aus der Dokumentation des Moduls =window-select=: https://github.com/hlissner/doom-emacs/tree/develop/modules/ui/window-select

#+begin_src elisp
(custom-set-faces!
  '(aw-leading-char-face
    :foreground "black" :background "#F92660"
    :weight bold :height 2.5 :box (:line-width 10 :color "#F92660")))
#+end_src
***** TODO aw-leading-char-face automatisch an Theme anpassen
*** Zoom
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("z" . "zoom/resize")
               "z" #'+hydra/text-zoom/body
               "n" #'+hydra/window-nav/body))
#+end_src
** Completion
Ich verwende das =vertico=-Modul.
*** Embark
Darin enthalten ist auch =embark=. =embark-act= hat standardmäßig zwei Bindings: =LDR a= und =C-;=. Ersteres ist gut, zweiteres schlecht, weil das Semikolon auf der deutschen Tastatur auf der Umschalt-Ebene liegt. Daher:

#+NAME: remap-embark-act
#+begin_src elisp
(map! "C-ö"             #'embark-act
      (:map minibuffer-local-map
       "C-ö"            #'embark-act
       "C-ü"            #'embark-select
       "C-c C-ü"        #'embark-act-all
       "C-c C-ö"        #'embark-export))
#+end_src
** Kalender
#+begin_src elisp
(setq calendar-week-start-day 1)
#+end_src
** Keybindings allgemein
*** evil stuff
**** Leader, localleader, ex
Die Umlaute liegen auf meiner Tastatur (xoy) ganz gut, aber für den Doppelpunkt brauche ich die Umschalttaste. Daher scheint es mir eine gute Idee zu sein, wichtige Funktionen, die auf einer englischen Tastatur gut liegen, hierher zu binden.

Bisher hatte ich das Komme als localleader. Allerdings kollidiert das mit einem Vim-Befehl, den ich mir vielleicht angewöhnen möchte. Das "ü" ist genauso bequem zu erreichen wie der Beistrich und hat naheliegenderweise keine Kollisionen:
#+begin_src elisp
(setq doom-localleader-key "ü")
#+end_src

Außerdem möchte ich das "ä" für =evil-ex=, weil, wie gesagt, der Doppelpunkt auf meinen Tastatur weit schlechter zu erreichen ist.
#+begin_src elisp
(map! :map global-map
      :desc "ex"
      :nv "ä" #'evil-ex)
#+end_src

Außerdem komme ich von Spacemacs, daher möchte ich =M-x= auf =SPC SPC= haben
#+begin_src elisp
(map! :leader
      :desc "M-x" "SPC" #'execute-extended-command)
#+end_src
**** visual line navigation
Damit im Normalmodus die Navigation innerhalb von umgebrochenen langen Zeilen funktioniert, muss ~evil-respect-visual-line-mode~ gesetzt werden, und zwar schon in =init.el=:

#+begin_src elisp :tangle no
(setq evil-respect-visual-line-mode t)
#+end_src
**** evil-matchit
#+begin_src elisp
(global-evil-matchit-mode 1)
#+end_src
** Abbrevs
Ich verwende gerne und ausgiebig abbrevs. Gerade für immer wiederkehrenden Fluff. Hier also der Pfad zur entsprechenden Datei:

#+begin_src elisp
(setq abbrev-file-name (concat doom-private-dir "my-abbrevs"))
(set-default 'abbrev-mode t)
(setq save-abbrevs 'silently)
#+end_src
** Load Path
#+begin_src elisp
(add-to-list 'load-path (concat (getenv "HOME") "/.doom.d/lisp/")  )
#+end_src
* Sprachen
** LSP allgemein
In =init.el= habe ich ~lsp~ aktiviert. Bei den entsprechenden Sprachen ist dementsprechend auch das Flag ~lsp~ zu setzen.

Damit auch in org-src-Puffern LSP unterstützung da ist, braucht muss diese Funktion vorhanden sein (mit der jeweiligen Sprache, hier =python= als Postfix):
#+begin_src emacs-lisp
(defun org-babel-edit-prep:python (babel-info)
  (setq-local buffer-file-name (->> babel-info caddr (alist-get :tangle)))
  (lsp))
#+end_src

Siehe hier: https://github.com/emacs-lsp/lsp-mode/issues/2842

** Common Lisp
:LOGBOOK:
:CREATED: 2022-01-10
:LAST_EDIT: 2022-01-28
:END:

** denote
Derzeit gibt es kein Modul für =denote= (vielleicht schreibe ich mal eines), also kommt das package in [[*=packages.el=][=packages.el=]].

*DOKUMENTATION:* https://protesilaos.com/emacs/denote

*** Grundkonfiguration
Im der Doku gibt es eine Beispielkonfiguration. Siehe dort.

Zuallererst müssen wir das Paket laden und das Verzeichnis festlegen, in dem die Dateien abgelegt werden.
#+begin_src elisp
(use-package! denote
  :init
  (setq denote-directory (expand-file-name "~/projects/notes/"))
  (setq denote-known-keywords '("basex" "emacs" "meeting" "xquery"))
  (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories))
#+end_src
*** Keybindings
#+begin_src elisp
(map! :after denote
      :leader
      (:prefix ("d" . "denote")
               "n" #'denote))
#+end_src
#+end_src
*** Zusätzliche Pakete
**** TODO =citar-denote=
https://github.com/pprevos/citar-denote/
**** TODO =consult-notes=
https://github.com/mclear-tools/consult-notes
**** TODO =denote-menu=
https://github.com/namilus/denote-menu
** drools
Für drools habe ich folgendes gefunden: https://github.com/pdorrell/rules-editing-mode. Dafür gibt es kein MELPA-Paket, daher habe ich eine lokale Kopie gemacht und [[Load Path][load-path]] angepasst.

Initialisierung:
#+begin_src elisp
;; (autoload 'drools-mode "drools-mode")
(require 'drools-mode)

(defun set-extension-mode (extension mode)
  (setq auto-mode-alist
	(cons (cons (concat "\\" extension "\\'") mode)
	      auto-mode-alist) ) )

(set-extension-mode ".drl" 'drools-mode)
(set-extension-mode ".dslr" 'drools-mode)
(set-extension-mode ".src" 'drools-mode)
#+end_src

** Markdown
*** externe Abhängigkeiten
Für die Funktion =markdown-preview= braucht man einen Markdown-Compiler:

#+begin_src shell :tangle no
sudo npm --global install marked
#+end_src

GFM kann man sich mit =grip-mode= auch im Browser ansehen. Dafür muss man das entsprechende Flag (=+grip=) in =init.el= setzen und =grip= installieren:

#+begin_src shell :tangle no
pip3 install grip
#+end_src

*** ToC beim Speichern aktualisieren
Wenn man mit =markdown-toc-generate-toc= ein Inhaltsverzeichnis eingefügt hat, will man wahrscheinlich auch, dass das beim Speichern automatisch aktualisiert wird. Daher:

#+begin_src emacs-lisp
(add-hook 'markdown-mode-hook
          (lambda ()
            (add-hook 'before-save-hook 'markdown-toc-refresh-toc nil 't)))
#+end_src

Danke Stackoverflow! https://stackoverflow.com/questions/6138029/how-to-add-a-hook-to-only-run-in-a-particular-mode
*** Fontification von Code-Blocks
#+begin_src emacs-lisp
(setq markdown-fontify-code-blocks-natively t)
#+end_src

** org-mode
:LOGBOOK:
CLOCK: [2022-02-08 Di 16:48]--[2022-02-08 Di 16:53] =>  0:05
:END:
*** Allgemein
Der Ordner, in dem meine org-files wohnen und wo die Attachments hingehen:

#+NAME: org-directories
#+begin_src elisp :tangle no
(setq org-directory "~/Nextcloud/org"
      org-attach-id-dir "~/Nextcloud/org/attach")
#+end_src

Und damit jedes mal, wenn ein Attachment angelegt wird, ein Link in =org-stored-links= kommt, den man dann mit =C-c C-l= einfügen kann:
#+NAME: org-attach-store-link-p
#+BEGIN_SRC elisp
(setq org-attach-store-link-p 'attached)
#+END_SRC
**** TODO Timestamps bei Überschriften einfügen
:PROPERTIES:
:CREATED:  [2022-02-02 Mi 09:06]
:END:
https://stackoverflow.com/questions/12262220/add-created-date-property-to-todos-in-org-mode
**** Inhalt von src-Blöcken extrahieren
Um (für XQuery) Inhalte von Blöcken in header-args übernehmen zu können, braucht es eine Funktion, die den Inhalt eines Codeblocks extrahiert.

#+name: local-org-extract-src-content
#+begin_src elisp :tangle no
(defun local-org-extract-src-content (name)
  (save-excursion
    (org-babel-goto-named-src-block name)
    (org-element-property :value (org-element-at-point))))
#+end_src

Danke Stackoverflow! https://emacs.stackexchange.com/questions/29131/get-contents-of-a-named-source-block
**** Relative file-links verwenden
Wenn file-links via =org-insert-link= eingefügt werden, sollen die Pfade relativ sein.
#+begin_src emacs-lisp
(setq org-link-file-path-type 'relative)
#+end_src

*** Agenda
Ohne Worte:

#+NAME: org-agenda-files
#+BEGIN_SRC elisp :tangle no
(add-to-list 'org-agenda-files "~/Nextcloud/org")
#+END_SRC
*** Keybindings
=C-c C-c= auf =localleader localleader=. In meiner [[*Leader, localleader, ex][derzeitigen Konfiguration]] heißt das =ü ü=.
#+begin_src elisp
(map! :after org
      :map org-mode-map
      :localleader
      doom-localleader-key #'org-ctrl-c-ctrl-c)
#+end_src
*** LaTeX-Eport
**** Klassen
***** Koma Article
Die wichtigste Klasse für mich ist der KOMA-Artikel. Diese Klassendefinition habe ich von hier: [[https://orgmode.org/worg/exporters/anno-bib-template-worg.html#orgf3daba4]]

#+NAME: koma-article
#+BEGIN_SRC elisp :tangle no
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("koma-article"
                 "\\documentclass[12pt,a4paper]{scrartcl}
                \\usepackage[english,ngerman]{babel}
                \\usepackage{microtype}
                \\usepackage{tgpagella}
                \\linespread{1.05}
                \\usepackage[scale=.9]{tgheros}
                \\usepackage{tgcursor}
                \\usepackage{paralist}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
*** ob-xquery
=org-babel=-Integration für XQuery. Voraussetzung ist, dass =basex= installiert ist. Der Code ist in [[~/.doom.d/lisp/ob-xquery.el]]. Natürlich müssen wir es initialisieren:

#+name: ob-xquery
#+begin_src elisp :tangle no
(require 'ob-xquery)
(add-to-list 'org-babel-load-languages '(xquery . t))
(add-to-list 'org-structure-template-alist '("x". "src xquery"))
#+end_src
*** ox-twiki
Um Wikitext für Foswiki exportieren zu können, verwende ich dieses Modul:

https://github.com/dfeich/org8-wikiexporters

Ich habe =ox-twiki.el= in meinen load-path (=~/.doom.d/lisp/=) kopiert und braucht es noch:

#+name: ox-twiki
#+begin_src elisp :tangle no
(use-package! ox-twiki)
#+end_src
*** ox-gfm
Der standard-Exporter für Markdown kann nur Basis-Markdown. D. h. Tabellen etc. werden in HTML umgewandelt. Damit die erweiterte Syntax von GitHub Flavored Markdown zum Einsatz kommt, füge ich =ox-gfm= zu den =packages.el= hinzu. Damit es auch im dispatcher aufscheint, muss man das Paket auch laden:

#+name: ox-gfm
#+begin_src emacs-lisp
(use-package! ox-gfm)
#+end_src

*** org-noter
Zuerst muss das ~+noter~-flag in =init.el= gesetzt sein. Ich habe meine Literatur in einem Verzeichnis, die Notizen dazu in einem anderen. Jedenfalls ist das Verzeichnis, das ich für die Notizen verwende nicht dort, wo es defaultmäßig konfiguriert ist. Daher:
#+begin_src elisp
(setq org-noter-notes-search-path '("~/Nextcloud/literatur/notes/"))
#+end_src

**** TODO Keybindings
=doom-leader-notes-map =
#+begin_src elisp
(map! :leader
       :desc "org-noter-insert-note" "n i" #'org-noter-insert-note
       :desc "org-noter-insert-precise-note" "n I" #'org-noter-insert-precise-note)
#+end_src
*** HOLD org-roam
:PROPERTIES:
:LAST_EDIT: 2021-01-14
:END:
*2023-11-02: Modul deaktiviert* Ich will es vorerst mal mit =denote= versuchen. Wenn ich mehr brauche, kann ich das dann immer noch machen. Daher liegt das da mal auf Eis. Wichtig: Man kann beide Packages (=denote= und =org-roam2=) gleichzeitig verwenden, indem man einfach nur für die richtige ID sorgt (nicht von mir selbst getestet, aber ich werde es in =denote= mal so konfigurieren, dass ich dann problemlos migrieren kann): https://org-roam.discourse.group/t/denotes-file-naming-scheme-and-org-roam/2769/4


Mir gefällt die Idee, den Luhmannschen Zettelkasten in =org-mode= zu implementieren, also probiere ich das mal aus. Dazu muss in =init.el= bei ~org~ das Flag ~+roam2~ gesetzt sein.

Dokumentation zu =org-roam= gibt es unter https://www.orgroam.com/manual.html, bzw. direkt im Emacs-Info-System (=SPC h i=).

Zuerst muss =org-roam= wissen, wo die Dateien sind:
#+begin_src elisp :tangle no
(setq org-roam-directory "~/Nextcloud/org/org-roam/")
#+end_src

**** org-roam-bibtex
https://github.com/org-roam/org-roam-bibtex
Für integration mit =citar= etc.

Zuerst muss einmal das Paket geladen werden, etc. Dazu muss folgendes in =packages.el=:

#+name: org-roam-bibtex-packages
#+begin_src elisp :tangle no
(package! org-roam-bibtex
  :recipe (:host github :repo "org-roam/org-roam-bibtex"))

;; When using org-roam via the `+roam` flag
(unpin! org-roam)

;; When using bibtex-completion via the `biblio` module
(unpin! bibtex-completion helm-bibtex ivy-bibtex)
#+end_src

Und dann noch die Minimalkonfiguration:

#+name: org-roam-bibtex
#+begin_src elisp :tangle no
(use-package! org-roam-bibtex
  :after org-roam)
#+end_src
**** externe Abhängigkeiten
Für die Darstellung des Graphen sollte =graphviz= installiert sein:

#+begin_src shell :tangle no
sudo pkcon install graphviz
#+end_src
*** TODO org-tempo
Gewisse =org-struct-templates= werden expandiert, aber wenn ich =org-structure-template-alist= ändere, werden die neuen Templates nicht hinzugefügt. Es scheint, als ob ein anderer Mechanismus als =org-tempo= das macht. Damit meine Templates funktionieren, muss ich offenbar =org-tempo= extra aufrufen:

#+name: org-tempo
#+begin_src elisp
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("p" . "src python"))
#+end_src

Vielleicht gehe ich dem noch nach. Kann sein, dass =doom= das alles über =yasnippet= macht?

*** src block evaluation
Folgende Funktion (gefunden hier: [[https://emacs.stackexchange.com/questions/23870/org-babel-result-to-a-separate-buffer]]) sorgt dafür, dass der Output eines Codeblocks in einem eigenen Puffer angezeigt wird und das Ergebnis nicht in die Org-Datei geschrieben wird.
#+begin_src elisp
(defun my-babel-to-buffer ()
  "A function to efficiently feed babel code block result to a separate buffer"
  (interactive)
  (org-open-at-point)
  (org-babel-remove-result))
#+end_src

Natürlich will das auch ein keybinding haben:

#+begin_src elisp
(map! :after org
      :map org-mode-map
      :localleader (:prefix ("u" . "prefix")
                            doom-localleader-key #'my-babel-to-buffer))
#+end_src
*** Workflow
**** org-capture
:LOGBOOK:
=======
CLOCK: [2022-02-08 Di 17:17]--[2022-02-08 Di 17:20] =>  0:03
CLOCK: [2022-02-08 Di 17:08]--[2022-02-08 Di 17:17] =>  0:09
CLOCK: [2022-02-08 Di 16:36]--[2022-02-08 Di 16:44] =>  0:08
CLOCK: [2022-02-08 Di 15:03]--[2022-02-08 Di 15:15] =>  0:12
:END:

Ich verwende verschiedene Templates für =org-capture=. Sie werden alle in ~org-default-notes-file~ gespeichert, von wo ich sie dann in ihre jeweiligen Zieldateien verschiebe.

- "To Do" :: Erstellt ein TODO-Item. Nachdem es manchmal durchaus etwas dauert, einen Gedanken zu formulieren, wird hier auch die Stechuhr aktiviert und nach dem Schließen die vorige Uhr fortgesetzt.
- "Bearbeiten" :: Bucket für E-Mails, die irgendeine Aktion erfordern. Das setzt voraus, dass dieses Template von einem =mu4e=-Puffer aus aufgerufen wird. Es öffnet sich kein Capture-Fenster, sondern es wird nur der Eintrag in der Notizdatei erstellt.
- "Antworten" :: Im Prinzip wie "Bearbeiten". Allerdings bekommt es ein "SCHEDULED"-Property.
- "Notiz" :: Eine Notiz (mit Tag ~:NOTE:~)
- "Besprechung" :: Für Besprechungsnotizen, Zeit läuft.
- "Telefonat" :: Für Besprechungen am Telefon.


#+NAME: org-capture-templates
#+begin_src elisp :tangle no
  ;; Capture templates
  (setq org-capture-templates
        (quote (("t" "To Do" entry (file org-default-notes-file)
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("b" "Bearbeiten" entry (file org-default-notes-file)
                 "* TODO Bearbeiten: %:subject\n%U\n%a\n%i\n" :immediate-finish t)
                ("r" "Antworten ([r]eply)" entry (file org-default-notes-file)
                 "* TODO Antwort an %:from bezüglich %:subject\nSCHEDULED: %t\n%U\n%a\n" :immediate-finish t)
                ("n" "Notiz" entry (file org-default-notes-file)
                 "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
                ;; ("j" "Journal" entry (file+datetree org-journal-file)
                ;;  "* %?\n%U\n" :clock-in t :clock-resume t)
                ("B" "Besprechung" entry (file org-default-notes-file)
                 "* Besprechung mit %? :MEETING:\n%U" :clock-in t :clock-resume t)
                ("T" "Telefonat" entry (file org-default-notes-file)
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                )))
#+end_src

Die "Inbox"-Datei muss ich natürlich auch noch definieren:

#+NAME: org-default-notes-file
#+BEGIN_SRC elisp :tangle no
(setq org-default-notes-file (concat org-directory "/refile.org"))
#+END_SRC
*** tree-slide
#+NAME: tree-slide
#+begin_src elisp :tangle no
(require 'org-tree-slide nil t)
 (global-set-key (kbd "<f8>") 'org-tree-slide-mode)
  (global-set-key (kbd "S-<f8>") 'org-tree-slide-skip-done-toggle)
  (define-key org-tree-slide-mode-map (kbd "<f9>")
    'org-tree-slide-move-previous-tree)
  (define-key org-tree-slide-mode-map (kbd "<f10>")
    'org-tree-slide-move-next-tree)
  (define-key org-tree-slide-mode-map (kbd "<f11>")
    'org-tree-slide-content)
#+end_src
*** Die ~after!~-Sektion
Viele Dinge müssen erst geladen werden, nachdem =org= geladen wurde. Damit in den Codebeispielen oben nicht immer =after!=-Makros notwendig sind, werden sie hier alle per noweb in einem zusammengefasst.

#+begin_src elisp :noweb yes
(after! org
  <<org-directories>>
  <<org-agenda-files>>
  <<org-attach-id-dir>>
  <<org-tempo>>
  <<org-default-notes-file>>
  <<org-capture-templates>>
  <<org-attach-store-link-p>>
  <<koma-article>>
  <<ob-xquery>>
  <<ox-twiki>>
  <<ox-gfm>>
  <<local-org-extract-src-content>>
  <<tree-slide>>
  )
#+end_src

** python
*** LSP
=pyright= benötigt [[file:~/projects/system-config/config.org::*node][node]] > 12.

*** Formatter
=pyright= stellt als LSP-Server keine Formatierungsfunktion zur Verfügung. Daher muss als Backend für das ~format~ Modul =black= installiert sein:

#+begin_src bash :tangle no
sudo pip3 install black
#+end_src
*** Externe Abhängigkeiten
Der =doom doctor= ist unzufrieden mit mir. Es fehlen noch ein paar Pakete:

#+begin_src shell :tangle no
sudo pip3 install pyflakes isort pipenv nose pytest poetry
#+end_src
*** poetry
Poetry scheint permanent das venv zu checken, was nervt. Ich wechsle nicht permanent zwischen Projekten. Daher setze ich die Variable auf =projectile=. D. h. der check passiert nur beim Wechsel zwischen Projekten. Sollte hoffentlich passen. Mal sehen, wie es mit =org-babel= spielt.

#+begin_src emacs-lisp
(after! poetry
  (setq poetry-tracking-strategy 'projectile))
#+end_src
** shell
*** externe Abhängigkeiten
Für Linting von Shell-Skripten braucht man =shellcheck=. Das kann zwar mit =zsh= nichts anfangen, aber bei der Komplexität meiner Skripten reicht =bash= wohl meistens.

#+begin_src shell :tangle no
sudo pkcon install shellcheck
#+end_src
** TTL (Turtle)
Ich habe =ttl-mode= zu =packages.el= hinzugefügt.
** web
*** LSP
Hier verwende ich derzeit =html-ls=. Formatieren geht über diesen Server nicht, daher muss das Modul ~format~ aktiviert und =tidy= installiert sein:

#+begin_src bash :tangle no
sudo apt install tidy
#+end_src
*** externe Abhängigkeiten
Für Formatierung, Lining etc. werden noch externe Programme benötigt:

#+begin_src shell :tangle no
sudo pkcon install tidy
#+end_src

#+begin_src shell :tangle no
sudo npm --global install js-beautify stylelint
#+end_src

*** tidy
Die Einrückungen in der Standardeinsteillung nicht wirklich (alles unter ~<body>~ ist auf einer Ebene).

#+NAME: html-tidy
#+begin_src elisp
(set-formatter! 'html-tidy "tidy -q -indent --indent-spaces 2" :modes '(html-mode web-mode))
(set-formatter! 'html-tidy "tidy -q -xml -indent --indent-spaces 2" :modes '(nxml-mode))
#+end_src

** XML
*** Keybindings
#+begin_src elisp
(map! :after nxml-mode
      :map nxml-mode-map
      :localleader
      (:prefix ("t" . "test")
       "t" #'run-xspec-on-file))
#+end_src

*** LSP
Von ~(web +lsp)~ wird auch in ~nXML-mode~ LSP kofiguriert und beim ersten Start der xmlls installiert.
*** XQuery
Da ich viel XQuery brauche, habe ich =xquery-mode= in =packages.el= aktiviert. Zusätzlich habe ich noch ein modul geschrieben, das XQuery-Anfragen an BaseX schickt. Es befindet sich in [[~/.doom.d/lisp/basex.el]]. Das Verzeichnis ist im =load-path=, also müsste =require= hier reichen:

#+begin_src elisp
(use-package! xquery-mode
  :config
  (require 'basex))
#+end_src
**** Keybindings
#+begin_src elisp
(map! :after xquery-mode
      :map xquery-mode-map
      :localleader
      (:prefix ("r" . "run")
               "b" #'basex-run-buffer
               "r" #'basex-run-region
               "l" #'basex-run-line
               "o" #'basex-run-src-block))
#+end_src
*** XSpec
Das Schema für XSpec ist vorhanden und kann =nXml-mode= zur Verfügung gestellt werden: https://github.com/xspec/xspec/wiki/Integrating-with-Emacs

#+begin_src elisp :noweb yes
(after! nxml-mode
  (add-to-list 'rng-schema-locating-files "~/opt/xspec/editors/emacs/schemas.xml")
  (add-to-list 'rng-preferred-prefix-alist '("http://www.jenitennison.com/xslt/xspec" . "x"))
  <<run-xspec-on-file>>)
#+end_src

Damit ich xspec mit der gerade geöffneten Datei aufrufen kann, verwende ich diese Funktion:
#+NAME: run-xspec-on-file
#+begin_src elisp :tangle no
(defun run-xspec-on-file ()
  "Runs xspec on current file.
If call with prefix arg, the *Async Shell Command* buffer is not displayed.
"
  (interactive)
  (let ((cmd (concat "xspec " (buffer-file-name))))
    (if current-prefix-arg
        (async-shell-command-no-window cmd)
      (async-shell-command cmd))))
#+end_src
* Checkers
** spell
Nachdem in meinen Texten Deutsch und Englisch vorkommt, brauche ich einen Spellchecker, der zwei Wörterbücher gleichzeitig kann. Dementsprechend füge ich =init.el= ~(spell +flyspell +hunspell)~ hinzu und installiere =hunspell=:

#+begin_src shell :tangle no
sudo apt install hunspell hunspell-de-at-frami
#+end_src

~+flyspell~ ist notwendig, weil =spell-fu= nicht mit hunspell kann, und aspell nicht mit mehreren Wörterbüchern.

*** Wörterbücher konfigurieren
#+begin_src elisp
(after! ispell
  (if (equal system-type 'gnu/linux)
      (progn
        (setq ispell-program-name "hunspell")
        (setq ispell-dictionary "de_AT_frami,en_US")
        ;; ispell-set-spellchecker-params has to be called
        ;; before ispell-hunspell-add-multi-dic will work
        (ispell-set-spellchecker-params)
        (ispell-hunspell-add-multi-dic "de_AT_frami,en_US"))
    (setq ispell-dictionary "german8"))
  )
#+end_src


* app
** E-Mail
:PROPERTIES:
:ID:       801f7b26-1410-47be-8521-dc30087364b4
:END:
Ich benutze =mu4e= für meine Mails. Die Synchronisierung der Mails läuft über =mbsync=, gesendet werden die mails mit =msmtp=.

Die Version die aus den Paketquellen mit =apt= installiert wird, ist nicht mehr mit doom Emacs kompatibel. Daher muss =maildir-utils= via snap installiert werden. Die Snap-Version enthält auch =mu4e=.

- Doku zum Doom-Modul :: [[file:~/.emacs.doom.d/modules/email/mu4e/README.org::+TITLE: email/mu4e][email/mu4e/README.org]]
*** ~load-path~
Ich habe =mu= (und emacs) als snap installiert, daher muss der load-path angepasst werden.

#+begin_src elisp
(add-to-list 'load-path "/snap/maildir-utils/current/share/emacs/site-lisp/mu4e/")
#+end_src

#+begin_src elisp :tangle no
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/")
#+end_src

*** Main view
**** Shortcuts zu den wichtigsten Ordnern
#+NAME: mu4e-maildir-shortcuts
#+begin_src elisp :tangle no
(setq mu4e-maildir-shortcuts
        '(("/obvsg/INBOX" . ?i)
          ("/schuhu/INBOX" . ?s)
          ("/gmail/INBOX" . ?g)
          ("/schuhu_mjn/INBOX" . ?m)
          ))

#+end_src
**** Bullets
Mir gefallen die bullets im main view noch weniger als die ursprünglichen Sternchen. Außerdem stehen im Bereich "Basics" immer noch die Sternchen. Also machen wir wieder Sternchen, damit es konsistent ist.
#+NAME: bullets
#+begin_src elisp :tangle no
(setq +mu4e-main-bullet "*")
#+end_src

***** TODO herausfinden, warum ~+mu4e-main-bullet~ im Bereich "Basics" nicht verwendet wird
Sobald ich das weiß, kann ich mich um ein anderes Symbol kümmern. So ist es inkonsistent und das ist (für mich) schlimmer als hässlich.


*** Allgemeine Konfiguration
#+NAME: mail-general
#+begin_src elisp :tangle no
(setq
 mu4e-confirm-quit nil ; quit without asking
 mu4e-use-fancy-chars nil ; don't use icons, they mess up the linespacing
 mu4e-attachment-dir "~/Downloads"
 mu4e-maildir (expand-file-name "~/Maildir")
 mu4e-get-mail-command "mbsync schuhu obvsg gmail"
 mu4e-update-interval 180 ;; check for mail every 3 minutes
 sendmail-program (executable-find "msmtp")
 send-mail-function #'smtpmail-send-it
 message-sendmail-f-is-evil t
 message-sendmail-extra-arguments '("--read-envelope-from")
 message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

In der ursprünglichen Einstellung hat das Datum im header-view keinen Platz.
#+NAME: headers-fields
#+begin_src elisp :tangle no
(setq mu4e-headers-fields
        '((:account-stripe . 1)
          (:human-date . 10)
          (:flags . 6) ; 3 icon flags
          (:from-or-to . 25)
          (:subject)))
#+end_src
*** Konten einrichten
#+NAME: mail-accounts
#+begin_src elisp :tangle no
(set-email-account! "obvsg"
                    '((user-mail-address . "stefan.schuh@obvsg.at")
                      (user-full-name . "Stefan Schuh")
                      (mu4e-drafts-folder . "/obvsg/Drafts")
                      (mu4e-sent-folder . "/obvsg/Sent")
                      (mu4e-trash-folder . "/obvsg/Trash")
                      (mu4e-refile-folder . "/obvsg/Archiv")
                      (mu4e-compose-signature . (concat

"Stefan Schuh     Die Österreichische Bibliothekenverbund und Service\n"
"                                               Gesellschaft m. b. H.\n"
"Tel: +43 1 4035158-65                  A-1020 Wien, Raimundgasse 1/3"
))
                      ))
(set-email-account! "schuhu"
                    '((mu4e-sent-folder . "/schuhu/Gesendet")
                      (mu4e-drafts-folder . "/schuhu/Drafts")
                      (mu4e-trash-folder . "/schuhu/Papierkorb")
                      (mu4e-refile-folder . "/schuhu/Archiv")
                      (user-mail-address . "stefan@schuhu.at")
                      (user-full-name . "Stefan Schuh")
                      (mu4e-compose-signature . (concat
                                                 "Stefan Schuh\n"
                                                 "Maria-Pachleitner-Straße 51/10\n"
                                                 "8053 Graz"))))

(set-email-account! "mjn-schuhu"
                    '((mu4e-sent-folder . "/schuhu_mjn/Gesendet")
                      (mu4e-drafts-folder . "/schuhu_mjn/Drafts")
                      (mu4e-trash-folder . "/schuhu_mjn/Papierkorb")
                      (mu4e-refile-folder . "/schuhu_mjn/Archiv")
                      (user-mail-address . "mjn@schuhu.at")
                      (user-full-name . "Mutant Admin")
                      (mu4e-compose-signature . (concat
                                                 "Dämmergewölbe 3, Die Arche"))
                      ))

(set-email-account! "gmail"
                    '((user-mail-address . "stefan.schuh.ba@gmail.com")
                      (user-full-name . "Stefan Schuh")
                      (mu4e-drafts-folder . "/gmail/drafts")
                      (mu4e-sent-folder . "/gmail/sent")
                      (mu4e-trash-folder ."/gmail/trash")
                      ))
#+end_src

*** Kontexte
Hier muss in Doom Emacs offenbar nicht so viel gemacht werden. Durch das einrichten der Accounts mit dem Makro ~set-email-account!~ funktioniert das Umschalten der Kontexte ohne weitere Konfiguration bisher völlig zu meiner Zufriedenheit.

*** Mail senden
:PROPERTIES:
:ID:       9dc6ef65-8349-4f76-81ad-cc38b1766a2c
:END:
Wie im Block [[mail-general][mail-general]] zu sehen ist, ist werden die Mails über =msmtp= gesendet. Die Konfiguration ist in meiner globalen Konfiguration: [[file:~/projects/system-config/config.org::*=msmtp=][=msmtp=]]
*** Benachrichtigungston
Ich will nicht, dass ein Ton abgespielt wird, wenn es neue E-Mails gibt.

#+name: mu4e-alert-bell-cmd
#+begin_src elisp
(setq +mu4e-alert-bell-cmd nil)
#+end_src

*** Alles zusammensetzen :noexport:
Hier die Mail-Konfiguration als ganzes:
#+NAME: mail
#+begin_src elisp :noweb yes
(after! mu4e
   ;; load package to be able to capture emails for GTD
   ;; (require 'org-mu4e)
   <<mu4e-maildir-shortcuts>>
   <<bullets>>
   <<mail-general>>
   <<mail-accounts>>
   <<headers-fields>>
   <<mu4e-alert-bell-cmd>>
   )
#+end_src
** Emacs everywhere
Für Emacs everywhere muss ich nicht viel mehr tun, als die Zeile in =init.el= von ihren Kommentaren zu befreien. Zusätzlich hätte ich gerne die gewohnte Kombination =localleader localleader= für =C-c C-c=:

#+begin_src elisp
(after! emacs-everywhere
  (map! :map emacs-everywhere-mode-map
        :desc "finish or C-c C-c"
        :localleader doom-localleader-key #'emacs-everywhere-finish-or-ctrl-c-ctrl-c))
#+end_src


* tools
** biblio
In =init.el= habe ich ~biblio~ aktiviert. Hier nun die entsprechende Konfiguration:

#+NAME: citar-paths
#+begin_src elisp
(setq! citar-bibliography '("~/Nextcloud/literatur/bibliographie.bib")
       citar-library-paths '("~/Nextcloud/literatur/files/")
       citar-notes-paths '("~/Nextcloud/literatur/notes/"))
#+end_src
** dired
*** =dired-listing-switches=
Die Optionen, die =ls= mitgegeben werden. =-l= muss immer mitgegeben werden.

- =a= :: alle Dateien (auch die, die mit "." beginnen) anzeigen
- =h= :: menschenlesbare Größenangaben
- =l= :: long-listing
- =v= :: Näturliche Sortierung von Zahlen in Dateinamen

#+begin_src emacs-lisp
(setq dired-listing-switches "-ahlv --time-style=long-iso --group-directories-first")
#+end_src


*** Gelöschte Dateien in Papierkorb verschieben
Sicher ist sicher.

#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t
      trash-directory "~/.local/share/Trash/files/")
#+end_src

Symlink zum Papierkorb ins Home-Verzeichnis (zur Bequemlichkeit):
#+begin_src shell :tangle no
cd ~/
ln -s ~/.local/share/Trash .
#+end_src

** ebib
Zur Verwaltung von bibtex-Daten verwende ich =ebib=. Dafür gibt es kein Doom-Modul, also füge ich =ebib= zu [[* =packages.el=][=packages.el=]] hinzu.

#+begin_src emacs-lisp
;; use biblatex
(setq ebib-bibtex-dialect 'biblatex)

;; always load my main .bib-file
(setq ebib-preload-bib-files '("~/Nextcloud/literatur/bibliographie.bib"))
#+end_src


*** Generieren von cite-keys
Die Art, wie die Keys von =bibtex-generate-autokey= gebildet werden, gefällt mir nicht. Also sorgen wir vorerst mal dafür, dass die Keys immer die Form =authorYear= haben. Das kann natürlich auch zu uneindeutigen Keys führen. Daher setzen wir =ebib-uniquify-keys=, damit =ebib= automatisch einen Buchstaben anhängt:

#+begin_src emacs-lisp
(setq bibtex-autokey-name-year-separator ""
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-year-length 4
      bibtex-autokey-titleword-length 0
      bibtex-autokey-titlewords 0
      ebib-uniquify-keys t)
#+end_src

*CAVEAT*: Wenn es keine Verfasser:in gibt, ist der cite-key nur das Jahr. Da muss man dann halt nacharbeiten.

*** Dateien
Wenn ich zu einem Zitat ein PDF habe, kommt dieses in =files/{citekey}.pdf=. D. h.

#+begin_src emacs-lisp
(setq ebib-file-search-dirs '("~/Nextcloud/literatur/files"))
#+end_src

**** Öffnen von Dateien
=Ebib= versucht, pdf-Dateien mit =xpdf= zu öffen. Das habe ich gar nicht installiert. Eigentlich möchte ich sie mit =pdftools= ansehen, daher setze ich den Wert in der =ebib-file-associations= auf =nil=.

#+begin_src emacs-lisp
(after! ebib
  (setf (alist-get "pdf" ebib-file-associations) nil))
#+end_src
*** Keybindings
Ebib starten etc.:

#+begin_src emacs-lisp
(map!  :leader
       (:prefix ("e" . "ebib")
                "e" #'ebib
                "i" #'ebib-import-entries
                "I" #'ebib-import-file
                "q" #'ebib-quit
                "z" #'ebib-lower))
#+end_src

=ebib-index-mode-map=:

#+begin_src emacs-lisp
(map! :after ebib
      :map ebib-index-mode-map
      :localleader
      :desc "Save current database" "s" #'ebib-save-current-database
      :desc "Save all databases" "S" #'ebib-save-all-databases)

#+end_src


=ebib-entry-mode-map=:
#+begin_src emacs-lisp
(map! :after ebib
      :map ebib-entry-mode-map
      :desc "copy field contents" "y" #'ebib-copy-current-field-contents
      :desc "kill field contents" "d" #'ebib-kill-current-field-contents
      :desc "insert into field" "p" #'ebib-yank-current-field-contents)

(map! :after ebib
      :map ebib-entry-mode-map
      :localleader
      :desc "Save current database" "s" #'ebib-save-current-database
      :desc "Save all databases" "S" #'ebib-save-all-databases)
#+end_src


** magit
*** forge
Um auf gitlab-issues etc. zuzugreifen braucht es ein bisschen config.

Zuallererst muss ~(git +forge)~ in ~init.el~ gesetzt sein.


**** gitlab.obvsg.at als zu ~forge-alist~ hinzufügen
Das gitlab der obvsg ist natürlich nicht standardmäßig in ~forge-alist~ vorhanden, also fügen wir es hinzu:

#+begin_src elisp
(after! forge
(add-to-list 'forge-alist
             '("gitlab.obvsg.at"
               "gitlab.obvsg.at/api/v4"
               "gitlab.obvsg.at"
               forge-gitlab-repository)))
#+end_src
**** Authentifizierung

Dann muss ein access-token in gitlab generiert werden (unter Profil -> Accsess Tokens)

Dieser Access-Token muss dann in einer ~auth-source~ hinterlegt werden.

#+begin_src config :tangle no
machine gitlab.obvsg.at/api/v4
  login ss^forge
  password ****
#+end_src


In ~Doom Emacs~ ist hierfür ~.emacs.d/.local/state/authinfo.gpg~ vorgesehen. Dafür muss man aber jedes mal  die Passphrase eingeben ...

Daher kommen die Daten in ~~/.netrc~, die ich eh für ~smtpmail~ in Verwendung habe. Das muss dann aber auch gesagt werden:

#+begin_src elisp
(add-to-list 'auth-sources "~/.netrc")
#+end_src
** mrk2xml
*** Externes Python-Script
Ich habe ein Script namens "[[file:~/projects/tools/mrk2xml/mrk2xml.py][mrk2xml.py]]", das MARCBreaker (und das OBVSG-XML-Basisformat) in XML-Snippets umwandelt. Hier ein paar Funktionen, für entsprechende Aufrufe:

#+name: mrc-text-to-xml
#+begin_src elisp :tangle no
(require 'nxml-mode-expansions)
(defun mrc-text-to-xml-region (start end &optional flags)
  "Transform region of MARCBreaker (or similar) to MARC21 XML via `mrk2xml'."
  (interactive "r")
  (kill-region start end)
  (shell-command (concat  "mrk2xml "
                          (or flags "") " "
                          (shell-quote-argument (current-kill 0 t)))
                 (current-buffer)))

(defun mrc-text-to-xml-line (arg &optional flags)
  "Transform line of MARCBreaker (or similar) to MARC21 XML via `mrk2xml'.

If a prefix argument is given, the output of the command is inserted
without formatting and indenting."
  (interactive "P")
  (mrc-text-to-xml-region (line-beginning-position) (line-end-position) (or flags nil))
  (if (eq arg nil)
      (my-nxml-reformat-containing-element)))

(defun mrc-text-to-xml-inner-element (arg &optional flags)
  "Transform element contents (MARCBreaker) to MARC21 XML via `mrk2xml'.

If a prefix argument is given, the output of the command is inserted
without formatting and indenting."
  (interactive "P")
  (er/mark-nxml-inside-element)
  (mrc-text-to-xml-region (point) (mark) flags)
  (if (eq arg nil)
      (my-nxml-reformat-containing-element)))

(defun mrc-text-to-xml-from-clipboard (arg &optional flags)
  "Run `mrk2xml' with clipboard contents and insert output at point.

If a prefix argument is given, the output of the command is inserted
without formatting and indenting."
  (interactive "P")
  (shell-command "mrk2xml" (current-buffer))
  (if (eq arg nil)
      (my-nxml-reformat-containing-element)))

(defun my-nxml-reformat-containing-element ()
  (interactive)
  (save-excursion (er/mark-nxml-containing-element)
                  (+format/region (point) (mark))
                  (er/mark-nxml-containing-element)
                  (indent-region (point) (mark))))


(defun base-text-to-xml-region (start end)
  (interactive "r")
  (mrc-text-to-xml-region start end "-b"))

(defun base-text-to-xml-line (arg)
    (interactive "P")
    (mrc-text-to-xml-line arg "-b"))

(defun base-text-to-xml-inner-element (arg)
    (interactive "P")
    (mrc-text-to-xml-line arg "-b"))
#+end_src

#+RESULTS: mrc-text-to-xml
: my-nxml-reformat-containing-element

*DEPENDENCY:*
=mrc-text-to-xml-inside-element= benötigt das Paket =expand-region.el=. Dieses wird von =doom= mitinstalliert. Der Namespace =+format= gehört auch zu =doom=.

#+name: mrc-text-to-xml-keybindings
#+begin_src elisp
(map! :after nxml-mode
      :map nxml-mode-map
      :localleader
      (:prefix ("m" . "mrc-text-to-xml")
               "c" #'mrc-text-to-xml-from-clipboard
               "e" #'mrc-text-to-xml-inner-element
               "r" #'mrc-text-to-xml-region
               "m" #'mrc-text-to-xml-line)
      (:prefix ("b" . "base-text-to-xml")
               "e" #'base-text-to-xml-inner-element
               "r" #'base-text-to-xml-region
               "b" #'base-text-to-xml-line))

#+end_src

Das sollte aber erst geladen werden, wenn =nxml= geladen wird:

#+begin_src elisp :noweb yes
(after! nxml-mode
  <<mrc-text-to-xml>>
  <<mrc-text-to-xml-keybindings>>
  )
#+end_src
*** Elisp
#+begin_src emacs-lisp
(require 'mrk2xml)
(mrk2xml-doom-bind-keys)
#+end_src
* temp
#+begin_src emacs-lisp
(font-lock-add-keywords
 'drools-mode
 `(
   ;; tags and indicators
   ("^=\\(00[1-9]\\)"
    (1 font-lock-keyword-face))
   ("^=\\([0-9]\\{3\\}\\) ?\\(..\\).*\\$\\$"
    (1 font-lock-keyword-face)
    (2 font-lock-type-face))
   ;; subfields
   ("\\(\\$\\$.\\)"
    (1 font-lock-function-name-face))
   )
t)
#+end_src



* =packages.el=
#+name: packages
#+begin_src elisp :noweb yes :tangle packages.el
;; <<org-roam-bibtex-packages>>

(unpin! evil-collection)
(package! xquery-mode)
(package! evil-matchit)
(package! ttl-mode)
(package! sparql-mode)
(package! dokuwiki)
(package! dokuwiki-mode)
(package! biblio)
(package! ebib)
(package! ox-wk)
(package! ox-gfm)
(package! denote)
(package! typst-ts-mode
  :recipe (:host sourcehut :repo "meow_king/typst-ts-mode"))
#+end_src
